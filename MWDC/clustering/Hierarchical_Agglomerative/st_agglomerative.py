# -*- coding: utf-8 -*-
"""st_agglomerative.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SBpBw1FhyqG2WuL-Kqmpf73uKAchbRab
"""

#!pip install "dask[dataframe]" #Needed for data transformation

import pandas as pd
import numpy as np
import xarray as xr
import netCDF4 as nc
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from scipy.cluster.hierarchy import dendrogram, linkage
import scipy.cluster.hierarchy as sch
from sklearn.cluster import AgglomerativeClustering

from multivariateweatherdataclusteringmain.MWDC.preprocessing import *


def st_agglomerative(input, K, affinity, linkage):
  '''
  input parameters:

        input: 4-d spatio-temporal xarray

        k : interger, The number of our desired clusters

        proximity: function, The distance metric

        linkage: function, Linkage criteria

  Output:
         
        formed_clusters: 1-D array of cluster labels classifying each data point along the time dimension
                         to a cluster label

        A dataframe showing each cluster label and the correcponding cluster size.

        A dendrogram showing the steps in clustering
     
  '''


  #calling function that transforms our data
  trans_data = datatransformation(input)

  #Normalize data
  norm_data = datanormalization(trans_data)

  # calling the agglomerative algorithm and choosing n_clusters = 4 based on elbow value
  model = AgglomerativeClustering(K, affinity = 'euclidean', linkage = 'average')
  
  # training the model on transformed data
  y_model = model.fit(norm_data)
  labels = y_model.labels_

  df1 = pd.DataFrame(norm_data)
  df1['Cluster'] = labels
  df1['Cluster'].value_counts()

  #print("Estimated number of clusters: %d" % n_clusters_)
  print(df1['Cluster'].value_counts())

  # graph size
  plt.figure(1, figsize = (24 ,12))

  # creating the dendrogram
  dendrogram = sch.dendrogram(sch.linkage(norm_data, method  = "ward"))

  plt.axhline(y = 85, color='orange', linestyle ="--")

  # var = list(input.variables)
  var = list(input.variables)

  # ploting graphabs
  plt.title('Dendrogram')
  plt.xlabel(var)
  plt.ylabel('Euclidean distances')
  plt.show()
  
  return df1,labels

#To call function: st_agglomerative(data, 7, affinity = 'euclidean', linkage = 'average')